#!/usr/bin/python3

import numpy as np
import json
import re
from os import path
import argparse


def liberty_float(f):
    """

    >>> liberty_float(1.9208818e-02)
    '0.0192088180'

    >>> liberty_float(1.5)
    '1.5000000000'

    >>> liberty_float(1e20)
    '1.000000e+20'

    >>> liberty_float(1)
    '1.0000000000'

    >>> liberty_float(True)
    Traceback (most recent call last):
        ...
    ValueError: True is not a float

    >>> liberty_float(False)
    Traceback (most recent call last):
        ...
    ValueError: False is not a float

    >>> liberty_float(0)
    '0.0000000000'

    >>> liberty_float(None)
    Traceback (most recent call last):
        ...
    ValueError: None is not a float

    >>> liberty_float('hello')
    Traceback (most recent call last):
        ...
    ValueError: 'hello' is not a float


    """
    try:
        f = float(f)
    except (ValueError, TypeError):
        raise ValueError("%r is not a float" % f)

    WIDTH = len(str(0.0083333333))

    s = json.dumps(f)
    if 'e' in s:
        a, b = s.split('e')
        if '.' not in a:
            a += '.'
        while len(a)+len(b)+1 < WIDTH:
            a += '0'
        s = "%se%s" % (a, b)
    elif '.' in s:
        while len(s) < WIDTH:
            s += '0'
    else:
        if len(s) < WIDTH:
            s += '.'
        while len(s) < WIDTH:
            s += '0'
    return s


def read_spicetxt(filepath, in_size=7):
    """ Reads the text file generated by the NGSPICE

    Parameters
    ----------
    filepath: str
        Location to a text file.

    in_size: int
        Size of the input vectors
        Default: 7 (taken as per "del_1_7_7")

    Returns
    -------
    input_transition : list
        Input Delay Vector(index_1)

    output_cap : list
        Output Capacitor Vector(index_2)

    timing_vector_2d : np.array(in_size * in_size)
        Timing Table Values.
    """

    with open(filepath, "r") as file_object:
        # read file content
        data = file_object.read()

    input_transition = []
    output_cap = []
    timing_vector = []
    # TODO: To format the vectors as per unit required in .lib file
    for per_in_data in data.split('\n'):
        agr_data = per_in_data.split(':')
        # print(agr_data)
        if len(agr_data) == 2:

            if agr_data[0] == 'input_transition':
                in_delay_val = re.sub('[a-z]+', '', agr_data[1])
                input_transition.append(liberty_float(in_delay_val))

        elif len(agr_data) == 4:

            if agr_data[0] == 'out_cap':
                out_cap_val = re.sub('[a-z]+', '', agr_data[1])
                output_cap.append(liberty_float(out_cap_val))

                timing_vector.append(liberty_float(agr_data[-1]))
    # Size of Cap Vector
    cap_size = len(list(set(output_cap)))
    # Size of Input Delay Vector
    delay_size = len(input_transition)
    # Resizing timing 1-D vector to 2-D
    timing_vector_2d = np.array(timing_vector)
    timing_vector_2d.resize(delay_size, cap_size)

    return input_transition, output_cap[:cap_size], timing_vector_2d

def read_seq_timing(file_loc):
    with open(file_loc, "r") as file_object:
        # read file content
        data = file_object.read()
    
    clk_tran = []
    d_tran = []
    seq_timing = []
    for per_in_data in data.split('\n'):
        agr_data = per_in_data.split(':')
        # print(agr_data)
        if len(agr_data) == 8:
            if agr_data[0] == 'clk_tran':
                in_delay_val = re.sub('[a-z]+', '', agr_data[1])
                clk_tran.append(liberty_float(in_delay_val))
                seq_timing.append(liberty_float(agr_data[-3]))

        elif len(agr_data) == 2:
            if agr_data[0] == 'd_tran':
                d_tran_val = re.sub('[a-z]+', '', agr_data[1])
                d_tran.append(liberty_float(d_tran_val))

    # Size of constraint Vector
    clk_tran_size = len(list(set(clk_tran)))
    # Size of related pin Vector
    d_tran_size = len(d_tran)
    # Resizing timing 1-D vector to 2-D
    timing_vector_2d = np.array(seq_timing)
    timing_vector_2d.resize(clk_tran_size, d_tran_size)
    timing_vector_2d = np.transpose(timing_vector_2d)
    return d_tran, clk_tran[:clk_tran_size], timing_vector_2d           
                
def timing_generator(files_folder, unate, related_pin='A', timing_type='combinational'):
    """Generates the timing block in .lib format  """
    # TODO: Make Global variable
    attributes_names = ['cell_fall', 'cell_rise',
                        'fall_transition', 'rise_transition',
                        'fall_power', 'rise_power']
    timing_tables = []
    for attr_name in attributes_names:
        file_name = attr_name + '.txt'
        file_location = path.join(files_folder, file_name)
        in_rises, out_caps, timing_table = read_spicetxt(file_location)
        if 'fall_power' == attr_name or 'rise_power' == attr_name: type_sim = 'power'
        else: type_sim = 'timing'
        each_attributes = gen_lib(in_rises, out_caps, timing_table, attr_name, type_sim)
        timing_tables.append(each_attributes)

    timing_str = \
    f"""timing () {{
                {timing_tables[0]}
                {timing_tables[1]}
                {timing_tables[2]}
                related_pin : "{related_pin.upper()}";
                {timing_tables[3]}
                timing_sense : "{unate}";
                timing_type : "{timing_type}";
            }} """

    power_str = \
    f"""internal_power () {{
                {timing_tables[4]}
                related_pin : "{related_pin.upper()}";
                {timing_tables[5]}
            }} """

    return timing_str, power_str

def gen_lib(in_rises, out_caps, data_table, attr_name, type_sim= 'timing'):
    """Format the each attribute content in .lib format """
    in_size = len(in_rises)
    out_size = len(out_caps)
    in_rises_str = ', '.join(in_rises)
    out_caps_str = ', '.join(out_caps)
    tables_data = ['"{}"'.format(', '.join(data_table[num]))
                   for num in range(len(data_table))]
    data_str = ', \\\n \t\t\t\t\t\t'.join(tables_data)
    
    if type_sim == 'timing': lut = f'del_1_{in_size}_{out_size}'
    elif type_sim == 'power': lut = 'power_outputs_1'
    elif type_sim == 'dff': lut = 'vio_3_3_1'

    data_cell = f"""{attr_name} ("{lut}") {{
                    index_1("{in_rises_str}");
                    index_2("{out_caps_str}"); 
                    values({data_str});
                }}"""
    return data_cell

def input_pins(file_path, active_pin, max_tran):
    """Sets up the input pins information for the cell group """
    max_tran_format = liberty_float(max_tran)
    file_path_loc = path.join(file_path, 'input_pins_caps.txt')
    with open(file_path_loc, 'r') as fop:
        data = fop.read()
    
    for row in data.split('\n'):
        row_sp = row.split(':')
        if len(row_sp) == 3:
            active_pin = row_sp[0]
            if 'fall' in row:
                fall_cap = row_sp[-1]
            elif 'rise' in row:
                rise_cap = row_sp[-1]
    
    try:
        avg_cap = (float(fall_cap)+float(rise_cap))/2
        avg_cap_format = liberty_float(avg_cap)
        fall_cap_format = liberty_float(fall_cap)
        rise_cap_format = liberty_float(rise_cap)
    except:
        avg_cap = 'Manual'
        avg_cap_format =  'Manual'
        fall_cap_format = 'Manual'
        rise_cap_format = 'Manual'

    pin_internal = \
        f"""pin ("{active_pin}") {{
            capacitance : {avg_cap_format};
            clock : "false";
            direction : "input";
            fall_capacitance : {fall_cap_format};
            max_transition : {max_tran_format};
            related_ground_pin : "VGND";
            related_power_pin : "VPWR";
            rise_capacitance : {rise_cap_format};
        }}"""
    
    return pin_internal

def input_pins_seq(file_path, active_pin, max_tran, extra_data='', clock_check=False):
    """Sets up the input pins information for the cell group in dff """
    clock_state = 'false' if not clock_check else 'true'
    max_tran_format = liberty_float(max_tran)
    file_path_loc = path.join(file_path, 'input_pins_caps.txt')
    with open(file_path_loc, 'r') as fop:
        data = fop.read()
    
    for row in data.split('\n'):
        row_sp = row.split(':')
        if len(row_sp) == 3:
            active_pin = row_sp[0]
            if 'fall' in row:
                fall_cap = row_sp[-1]
            elif 'rise' in row:
                rise_cap = row_sp[-1]
    
    try:
        avg_cap = (float(fall_cap)+float(rise_cap))/2
        avg_cap_format = liberty_float(avg_cap)
        fall_cap_format = liberty_float(fall_cap)
        rise_cap_format = liberty_float(rise_cap)
    except:
        avg_cap = 'Manual'
        avg_cap_format =  'Manual'
        fall_cap_format = 'Manual'
        rise_cap_format = 'Manual'

    pin_internal = \
        f"""pin ("{active_pin}") {{
            capacitance : {avg_cap_format};
            clock : "{clock_state}";
            direction : "input";
            fall_capacitance : {fall_cap_format};
            max_transition : {max_tran_format};
            related_ground_pin : "VGND";
            related_power_pin : "VPWR";
            rise_capacitance : {rise_cap_format};
            {extra_data}
        }}"""
    
    return pin_internal

if __name__ == '__main__':
    file_location = '/home/hshukla3/timing_archs/custom_stdcell/or2_0/data/input_caps/input_pins_caps.txt'
    input_pins(file_location, 'A', '1.5')
    # parser = argparse.ArgumentParser(
    #     description="Generates Timing Block using NGSPICE generated .txt files")
    
    # parser.add_argument('-loc', metavar='Location', help='Enter the location of all .txt files', 
    #                     type=str, required=True, default=file_location)
    
    # parser.add_argument('-pin', metavar='Relatable Pin', help='Enter the related pin Name', type=str, 
    #                     required= False, default='A')

    
    # argus = parser.parse_args()
    # unate = 'undefined'
    # timing_info = timing_generator(argus.loc, unate, related_pin=argus.pin)
    # print(timing_info)
